---
title: 内联缓存
date: 2020-05-25 14:05:11
tags:
  - HTML5
category: V8引擎
---

# 内联缓存

## 什么是内联缓存

首先内联缓存(后面称 IC)也并不是 V8 首创，这项技术也很古老，最初是应用在 Smalltalk 虚拟机上。IC 的原理简单来说就是在运动过程中，收集一些数据信息，将这部分信息缓存起来然后在再次执行的时候可以直接利用这些信息，有效的节省了再次获取这些信息的消耗，从而提高性能。

## 内联缓存是怎么运行的

我们可以通过分析一段字节码的运行来看一下内联缓存的运作，如果不了解字节码执行的同学可以先看 V8 引擎详解——字节码是如何执行的先来了解一下。
先来看下面一段代码

```javascript
function test(obj) {
  obj.y = 4;
  obj.x += 2;
  return obj.x;
}
test({ x: 1, y: 2 });
```

将 function 转成字节码的结构如图：

![](/images/inline01.png)

我们分析一下这段字节码(本文重点在于 IC 所以会侧重于涉及 IC 部分)：

- 进入函数先进行栈的检查，然后会将小数字 4 存入累加器。
  ![](/images/inline02.png)
- 将累加器的值传给`a0[0](obj.y)`,同时将**a0[0](obj.y)**的信息缓存到反馈向量表中的第 0 个`slot`（插槽）中。
  ![](/images/inline03.png)
- 加载 a0[1](obj.x) 的值到累加器中同时将 **a0[1](obj.x)**的信息缓存到 反馈向量 表中的第 2 个 slot（插槽）中。
  ![](/images/inline04.png)
- 将累加器中的值加 2，将结果值缓存到反馈向量 表中的第 4 个 slot（插槽）中，然后将累加器中的值赋予到 a0[1](obj.x) ，并将信息缓存到反馈向量 表中的第 5 个 slot（插槽）中。
  ![](/images/inline05.png)
- 最后当我们将 obj.x 中的值直接通过缓存取出到累加器中并将累加器中的值返回。
  ![](/images/inline06.png)

运行过程并不复杂，本质上就是标记一些调用点，然后为他们分配一个插槽缓存起来，当再次调用的时候直接通过缓存获取值。

## 内联缓存的单态与多态

事实上我们在调用函数的时候，可以通过缓存信息提高函数的执行效率，但是前提是我们传参的结构是固定的，那如果传递传参数的结构不是固定的内联缓存要如何处理呢？
这个就涉及到我们开篇的那个问题了，回到代码来看：

```javascript
console.time("t0"); // 计时开始
for (let i = 0; i < length; i++) {
  let obj1 = { x: 3, y: 2 }; // 为了保证创建对象消耗时间保持一致
  obj1[i] = 3;
  func(obj0);
}
console.timeEnd("t0"); // 计时
```

这段代码中的`func`调用的是固定的结构 obj0={x:1,y:2,z:3},所以可以通过内联缓存加速在执行上效率大大提高。
但是第二段代码中：

```javascript
console.time("t1"); // 计时开始
for (let i = 0; i < length; i++) {
  let obj1 = { x: 3, y: 2 };
  obj1[i] = 3;
  func(obj1);
}
console.timeEnd("t1"); // 计时结束
```

`func`调用的 obj2 每次执行结构都是变化的（i 的值一直在变），那么 v8 是如何处理的
这里面就涉及到了`多态内联缓存（Ploymorphic Inline Cache）`也就是`PIC`,所谓的 PIC 就是在同一个 Slot 位置上，不仅只缓存一份数据如图：
第一次执行函数的时候，v8 会将对象的一些信息记录到 slot 中，第二次执行函数会将第一次记录的信息和第二次的信息进行比较，如果相同直接调用，如果不同会将这部分信息记录在同一个位置。依次类推一个 slot 会记录多份信息（当然也是有一定数量限制的）。 同一个 slot 记录多个信息的情况就可以称之为 PIC 多态内联缓存，而多态内联缓存可能会进行多次的比较操作，自然性能上不如单态内联缓存，也就是为什么开篇中第二段函数执行的比第一段来的慢。
